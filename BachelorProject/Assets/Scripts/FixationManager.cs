using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

//TODO: Newly added dynamic gaze points are not supported by FixationManager yet
public class FixationManager : MonoBehaviour
{
    //#> Constants 
    [SerializeField] private const float distanceThreshold = 0.1f;  //< Tweakable
    [SerializeField] private const int pointCountThresholdForFixationCreation = 10;  //< Tweakable  //? Maybe change this so that the tweakable part states how long an are needs to be fixated? (calculate this against timer tick rate)

    //#> Static Variables 
    public static UnityEvent<Vector3, int, Vector3, DynamicObject> OnFixationCreated = new();

    //#> Private Variables 
    [SerializeField] private List<GazePoint> activeGazePointGroup = new(); //< Only serialized for visualization in editor
    [SerializeField] private List<Vector3> fixations = new List<Vector3>(); //< Only serialized for visualization in editor

    private void OnEnable()
    {
        GazePointManager.OnPointCreated.AddListener(EvaluateFixation);
    }

    private void OnDisable()
    {
        GazePointManager.OnPointCreated.RemoveListener(EvaluateFixation);
    }

    private void EvaluateFixation(GazePoint gazePoint)
    {
        Vector3 currentFixationGroupAveragePosition = CalculateAveragePosition(activeGazePointGroup);

        //TODO: Also, right now, this check can be tricked by looking at the upper edge, then the sky, which does not trigger this, as the sky does not generate new gazePoints, thereby not clearing the current list and not creating a fixation. The fixation is only created when a new gazepoint is generated by looking at another object. In the meantime, the character can do a 180, causing the raycast (for normal detection) on Fixation Creation to not hit the underlying object. This needs to be fixed.
        if (Vector3.Distance(gazePoint.position, currentFixationGroupAveragePosition) > distanceThreshold || IsDifferentIDthanLastEntry(gazePoint.dynObjID))
        {
            //TODO: Right now, the system sometimes creates new fixations, seemingly without reaching this threshold?
            if (activeGazePointGroup.Count > pointCountThresholdForFixationCreation) //< Collapse current active fixation group into a fixation, but only if it contains enough points.
                CreateFixation(currentFixationGroupAveragePosition, activeGazePointGroup[0].dynamicObject);

            activeGazePointGroup.Clear();
        }

        activeGazePointGroup.Add(gazePoint);
    }

    private Vector3 CalculateAveragePosition(List<GazePoint> gazePoints)
    {
        Vector3 sum = Vector3.zero;

        foreach (GazePoint point in gazePoints)
            sum += point.position;

        return sum /= gazePoints.Count; ;
    }

    private void CreateFixation(Vector3 fixationPosition, DynamicObject dynObj)
    {
        //TODO: This is still a little unreliable around the top edges, but generally workable

        Collider[] overlapHitObjects = Physics.OverlapSphere(fixationPosition, 0.01f);
        if (overlapHitObjects.Length == 0)
        {
            Debug.LogWarning($"Tried to create fixation at {fixationPosition}, but the overlap sphere failed to detect any colliders. Tweaking of variables is recommended.");
            return;
        }

        GameObject overlapHitObject = Physics.OverlapSphere(fixationPosition, 0.01f)[0].gameObject;
        Vector3 relativePosToHitObject = overlapHitObject.transform.position - fixationPosition;

        if (Physics.Raycast(origin: fixationPosition - relativePosToHitObject * 0.05f, direction: relativePosToHitObject, maxDistance: 0.5f, hitInfo: out RaycastHit hit, layerMask: Physics.DefaultRaycastLayers, queryTriggerInteraction: QueryTriggerInteraction.UseGlobal))
        // if (Physics.SphereCast(origin: position, radius: 0.1f, Vector3.up, out RaycastHit hit))
        {
            if (hit.collider.gameObject == overlapHitObject)
            {
                Vector3 surfaceNormal = hit.normal;
                fixations.Add(fixationPosition);
                OnFixationCreated.Invoke(fixationPosition, fixations.Count, surfaceNormal, dynObj);
            }
            else
                Debug.LogWarning($"Tried to create fixation at {fixationPosition}, but accidentally hit an object ({hit.collider.gameObject.name}) during normal-detection raycast that was not the intended target ({overlapHitObject.name}). Tweaking of variables is recommended.");
        }
        else
            //TODO: This implementation is still unable to generate hits on large, flat objects (like the ground plane), as these cause the raycast to turn parallel
            Debug.LogWarning($"Tried to create fixation at {fixationPosition}, but the normal-detection raycast missed ({overlapHitObject.name}). Tweaking of variables is recommended.");
    }

    private bool IsDifferentIDthanLastEntry(int id)
    {
        if (activeGazePointGroup.Count > 0)
            return id != activeGazePointGroup[activeGazePointGroup.Count - 1].dynObjID;
        else
            return false;
    }

    // private void OnDrawGizmos() //< For debug visualization
    // {
    //     float radius = 0.2f;
    //     Color gizmoColor = Color.red;

    //     for (int i = 0; i < fixations.Count; i++)
    //     {
    //         Vector3 thisFixation = fixations[i];

    //         Gizmos.color = gizmoColor;
    //         Gizmos.DrawSphere(thisFixation, radius);

    //         if (i + 1 <= fixations.Count - 1)   //< If the following check would not go out of bounds. (This is probably cheaper than a custom exception handler)
    //         {
    //             Vector3 nextFixation = fixations[i + 1];
    //             Gizmos.DrawLine(thisFixation, nextFixation);
    //         }
    //     }
    // }
}
